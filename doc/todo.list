一、捕获 Interface
思路
1 捕获默认全部捕获
2 根据过滤器过滤已捕获的包，基于 p4 的 BpfProgram 实现
3 每次重新开始捕获需要选择对以前已捕获包的处理（保存等等）
4 使用 getNextPacket 一个一个 dump，dump 同时对此数据包应用过滤器
5 中途更新过滤器的处理步骤需要好好考虑
    网卡的默认 handle 就是 loop+listener(dump)，而其余的处理则是仅仅利用网卡的 captureFilterConfig，在接口之外实现
    实现步骤如下：
    情况 1) 开始捕获->中途不修改过滤器->结束捕获
        a 默认 handle->getNextPacket->默认 handle->dumper->额外的 handle->bpf 判断->true 则将数据包送入其它模块处理
    情况 2) 开始捕获->中途修改过滤器->结束捕获
        a 默认 handle->getNextPacket->默认 handle->dumper->额外的 handle->bpf 判断->true 则将数据包送入其它模块处理
        b 更新了过滤器->a 过程永远运行->首先使用临时的 handle->loop 读取文件, 将数据包列表送入其它模块->继续 a 过程
6 todo 可同时开启多个捕获作业
7 todo 离线模式想好组织到哪里，只读取 pcap 文件

二、解析 PacketGroup+PacketOperator
包捕获后的处理，主要是协议类型未知是个难题
思路
1 连续判断是否包括下层数据包，基于 p4 的 utils.Packets
2 批量获取某些地址信息，基于 p4 的 utils.ByteArrays
3 计算各种校验和，基于 p4 的 utils.ByteArrays
4 批量对 Byte 的操作都可以看一下 utils.ByteArrays
时机
1 只解析当前过滤得到的数据包
2 因此当前过滤器得到的数据包应该拷贝成一个副本，放在内存之中
3 更新过滤器时，从磁盘缓冲区读取完整 pcap 文件（.pks）得到新的过滤结果
（以上思路画出数据流图）
内容
1 包的额外信息，额外信息通过 map 联系数据包，最后交由包组管理
2 包的全部可解析信息
如何
1 对每个数据包通过 forEach，利用 Packets 的方法判断都有哪些层的协议
2 p4 目前只支持，因此暂时支持这些，可以很简单的实现，如：
一定包含链路层，则先判断是否包括网络层，不包括则可能为：PPP、BSD 这些
包含网络层，则判断是否包含传输层，不包含则可能为 ARP、ICMP 这些
包含传输层、则判断 TCP 还是 UDP，判断应用层端口是哪些常用端口（暂时，因为应用层协议支持的少）
Ethernet, Linux SLL, raw IP, PPP (RFC1661, RFC1662), BSD (Mac OS X) loopback encapsulation, and Radiotap
IEEE 802.11
Probe Request
LLC and SNAP
IEEE802.1Q
ARP
IPv4 (RFC791 and RFC1349) and IPv6 (RFC2460)
ICMPv4 (RFC792) and ICMPv6 (RFC4443, RFC4861, and RFC6275)
TCP (RFC793, RFC2018, and draft-ietf-tcpm-1323bis-21), UDP, and SCTP (only common header)
GTPv1 (only GTP-U and GTP-C header)
DNS (RFC1035, RFC3596, and RFC6844)
3 todo 自己可暂时实现额外的协议

三、构造 Packet Operator
包构造的存储需要用到对象存储加载技术
1 提供丰富的模板，保存 packet 对象为二进制文件（.pk）
2 读入 packet 可修改某些必要的字段
3 手动构造包要用到判断是否包括下层数据包，基于 p4 的 utils.Packets
4 为每种支持的包编写特定的 fxml 布局

四、修改 Packet Operator
类似于构造，提供修改及重放功能

五、发送 Interface
将待发送的数据包复制到临时文件中
发送网卡从临时文件读取数据包，直接发送：这样做看似兜了圈子，其实提供了高可扩展性，且提高了性能（数据包在各种模块间的传递很耗费资源，需进行不必要的等待）
可以设置发送延迟，重传次数，及很多参数
所以，发送接口较为重要的是参数的设计，暂时就添加几个即可


六、配置 Config
对象与 Json 互转

七、包组

1 包的额外信息，额外信息通过 map 联系数据包，最后交由包组管理，注：包额外信息在真正使用的时候再通过迭代当前组的方式生成
todo 包的额外信息有哪些
map、包组以及之后的子包组都应该复用数据包（map 存储包的地址，包组存储 map 的地址），而不是复制

2 总体上分为在线组和离线组：总是离线+在线，且离线在在线的前面，捕获时，每更新一次过滤器就将在线组清空

todo 发送数据包和数据包组存储格式和组织方法

3 由于组需要大量的增操作，而对于访问组都是从头开始的，且需要访问有序，
又因为需要存储包和包信息的映射，因此选择的捕获组的数据结构为 LinkedHashMap





